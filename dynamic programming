动态规划是一个从其他行业借鉴过来的词语。
它的大概意思先将一件事情分成若干阶段，然后通过阶段之间的转移达到目标。由于转移的方向通常是多个，因此这个时候就需要决策选择具体哪一个转移方向。
动态规划所要解决的事情通常是完成一个具体的目标，而这个目标往往是最优解。并且：
1.阶段之间可以进行转移，这叫做动态。
2.达到一个可行解(目标阶段) 需要不断地转移，那如何转移才能达到最优解？这叫规划。

每次决策实际上不会考虑之后的决策，而只会考虑之前的状态。 形象点来说，其实是走一步看一步这种短视思维。为什么这种短视可以来求解最优解呢？那是因为：
我们将所有可能的转移全部模拟了一遍，最后挑了一个最优解。
无后向性（这个我们后面再说，先卖个关子）
而如果你没有模拟所有可能，而直接走了一条最优解，那就是贪心算法了。

有意义的递归通常会把问题分解成规模缩小的同类子问题，当子问题缩写到寻常的时候，我们可以直接知道它的解。然后通过建立递归函数之间的联系（转移）即可解决原问题。
一个问题要使用递归来解决必须有递归终止条件（算法的有穷性），也就是说递归会逐步缩小规模到寻常。

这个函数的自变量集合就是题目的所有取值，值域就是题目要求的答案的所有可能。我们的目标其实就是填充这个函数的内容，使得给定自变量 x，能够唯一映射到一个值 y。

比如我们定义一个递归函数 f(n)，用 f(n) 来描述问题。就和使用普通动态规划 f[n] 描述问题是一样的，这里的 f 是 dp 数组。

递归中如果存在重复计算（我们称重叠子问题，下文会讲到），那就是使用记忆化递归（或动态规划）解题的强有力信号之一。可以看出动态规划的核心就是使用记忆化的手段消除重复子问题的计算

无后效性决定了是否可使用动态规划来解决。
最优子结构决定了具体如何解决。
举个例子：如果考试中的分数定义为 f，那么这个问题就可以被分解为语文，数学，英语等子问题。显然子问题最优的时候，总分这个大的问题的解也是最优的。
背包问题中 f([1,2,3], [2,2,4], 10) 选择是否拿第三件物品，不应该影响是否拿前面的物品。比如题目规定了拿了第三件物品之后，第二件物品的价值就会变低或变高）。这种情况就不满足无后向性。

以上面提到的 f(start, end) 来说，含义是子串 s[start:end+1]的最长回文子串。表示方式我们不变，只是将含义变成子串 s[start:end+1]的最长回文子串，且必须包含 start 和 end。
经过这样的定义，实际上我们也没有必要定义 f(start, end)的返回值是长度了，而仅仅是布尔值就行了。如果返回 true， 则最长回文子串就是 end - start + 1，否则就是 0。
f(i,j)=f(i+1,j−1) and s[i] == s[j]

《10. 正则表达式匹配》难度困难。
以我们分析的 f(s_start, s_end, p_start, p_end) 来说，含义是子串 p1[p_start:p_end+1] 是否可以匹配字符串 s[s_start:s_end+1]。
实际上，我们可以定义更简单的方式，那就是 f(s_end, p_end)，含义是子串 p1[:p_end+1] 是否可以匹配字符串 s[:s_end+1]。也就是说固定起点为索引 0


强烈建议你每一道题都分析好复杂度一样


因为爬楼梯问题的状态转移方程中当前状态只和前两个状态有关，因此只需要存储这两个即可。 动态规划问题有很多这种讨巧的方式，这个技巧叫做滚动数组。
记忆化递归和动态规划除了一个用递归一个用迭代，其他没差别。那两者有啥区别呢？我觉得最大的区别就是记忆化递归无法使用滚动数组优化。
本质上来说， 记忆化递归采用的方式是 DFS，因此会一条路走到黑，然后返回来继续其他可行的路一口气再次走到黑。
而迭代使用的是类似 BFS 的方式，这样一层层访问，太远的层可能用不到了，就可以直接抹去，这就是滚动数组的本质。
