No.75 Sort Colors
三路快速排序的关键是，确定每个元素区间的范围，闭区间还是开区间。循环条件是区间之间没有交集（[li+1, i）和 [gt,r]的循环条件是i<gt, i这个未定元素进入某一个元素区间内部时，循环终止）。
在排序开始前，要保证三个区间里一个元素都没有 : lt = -1, gt = nums.size(), i从0开始。

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int> nums;
        
        for(int i = 0; i< m; i++){
            nums[i] = nums1[i];
        }
        
        int i, j = 0;
        for(int k = 0; k < m+n; k++){
            if( nums[i] < nums2[j] ){
                nums1[k] = nums[i];
                i++;
            }
            
            else if(nums[i] > nums2[j]){
                nums1[k] = nums2[j];
                j++;
            }
            
            else{
                nums1[k] = nums[i];
                k++;
                nums1[k] = nums2[j];
                i++;
                j++;
            }                  
        }
        
        
    }
};

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int> nums;
        for(int i = 0; i<m; i++)
            nums[i] = nums1[i];
        int i,j = 0;
        while(j < n){
            if(nums[i] < nums2[j]){
                nums1[i] = nums[i];
            }
                
            else if(nums1[i] > nums2[j]){
                
            }
        }
        
    }
};

No.167 对撞指针

No.209 滑动窗口

滑动窗口和对撞指针的区别：滑动窗口要求连续元素

No.349 Set的使用
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
       Set<Integer> set = new HashSet<>();  //set的初始化
        for(int i : nums1)
            set.add(i);
        
        Set<Integer> set2 = new HashSet<>();   //Set的循环
        for(int i : nums2)
            set2.add(i);
        
        List<Integer> result = new ArrayList<>(); //ArrayList的初始化
        
        for(int i : set2){
            if(set.contains(i)){
                result.add(i);
            }
        }
        
        int[] ints = new int[result.size()];    //Array的初始化
        for(int i = 0; i < result.size(); i++)
            ints[i] = result.get(i);          //ArrayList不能直接用[i]获取元素，要用get()
        
        return ints;
    }
}


No.350 Map的使用
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
    
    HashMap<Integer, Integer> m = new HashMap<>(); //Map的初始化
    for (int n : nums1) {
        m.put(n, m.getOrDefault(n, 0) + 1);        //将数组元素存入Map中
    }
    int k = 0;
    for (int n : nums2) {
        int cnt = m.getOrDefault(n, 0);            
        if (cnt > 0) {
            nums1[k++] = n;                       //为节省空间，可以使用已经被存储过的数据结构
            m.put(n, cnt - 1);                    //Map中元素使用完频率减一（更新Map）
        }
    }
    return Arrays.copyOfRange(nums1, 0, k);
    }
}

No.202 
//用set判断循环，比如分割某个数，几次循环之后又回到了最开始的数，那这就是死循环
Set<Integer> seen = new HashSet<>();
        
        while(true){
            if(seen.contains(n))
                return false;
            if(n==1)
                return true;
            seen.add(n);
            n = getNext(n);

No.1
public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> m = new HashMap<>();
        for(int i = 0; i < nums.length ; i++){
            m.put(nums[i], i);
        }
        
        for(int i = 0; i < nums.length ; i++){
            int compelement = target - nums[i];
            if(m.containsKey(compelement) && m.get(compelement)!=i){
                return new int[] {i, m.get(compelement)};
            }
        }
        throw new IllegalArgumentException("No two sum solution");

No.219
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set<Integer> set = new HashSet<>();
        for(int i = 0 ; i < nums.length ; i++){
            if(set.contains(nums[i]))             //判断两个数是否相等可以通过判断set中是否存在
                return true;
            set.add(nums[i]);
            if(set.size() > k)
                set.remove(nums[i-k]);    //把set当作滑动窗口，维持set中的元素数量是k
        }
        return false;
    }
}

No.206
ListNode prev = null;
ListNode curr = head;
     while(curr != null){               //以谁作为循环的判断条件，在循环内就必须以谁的更新结尾，为了确保不会出现null.next，如果还需要更新之后的节点，那就在每次循环的开始更新，需要这种更新的节点不用在循环外定义，在循环内定义即可
            ListNode next = curr.next;  //在下一次循环里更新上一次的next，只能用一定不为null的节点.next，因为null.next报错空指针
            curr.next = prev;
            prev = curr;
            curr = next;
        }

No.24
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null)
            return null;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        ListNode prev = dummy;                          //初始化到循环判断的那一个节点即可，剩下的要不不需要，要不就是需要在循环哪初始化
        ListNode firstnode = head;
        
        while(firstnode != null) {                      //以谁作为循环的判断条件，在循环内就必须以谁的更新结尾，为了确保不会出现null.next，如果还需要更新之后的节点，那就在每次循环的开始更新，需要这种更新的节点不用在循环外定义，在循环内定义即可                                                 
            ListNode secondnode = firstnode.next;       //在下一次循环里更新上一次的next，只能用一定不为null的节点.next，因为null.next报错空指针
            if(secondnode == null)
                break;
            
            prev.next = secondnode;
            firstnode.next = secondnode.next;
            secondnode.next = firstnode;
            
            prev = firstnode;                           //往前移动一个单位即可，因为已经两两交换了位置相当于移动了两个单位
            firstnode = prev.next;
            
        }
        
        return dummy.next;
    }
}


No.92
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if(head == null)
            return null;
        
        ListNode prev = null;
        ListNode curr = head;
        while(m > 1){                   //把prev和curr指针移到合适的位置，从左到右赋值
            prev = curr;
            curr = curr.next;
            m--;
            n--;
        }
        ListNode conA = prev;           //保存reverse前的prev和curr为了reverse后保证链表的顺序性，不会出现环
        ListNode tail = curr;   
        
        while(n > 0){
            ListNode next = curr.next;  //链表reverse需要三个指针：prev，curr，next
            curr.next = prev;
            prev = curr;
            curr = next;
            n--;
        }
        
        if(conA != null)               //已经reverse完的子链头节点（原先的尾节点）被之前存的prev（主链上一个节点）指向，子链的尾节点（原先的头节点）指向主链的下一个节点（可以为null）
            conA.next = prev;
        else                           //reverse完成后，prev指向子链的头节点，curr指向主链的下一个节点（可以为null）
            head = prev;               //若主链的上一个节点为null，则子链目前的头节点作为head
        
        tail.next = curr;
        return head;
    }
}

No.86
ListNode greater = new ListNode(0);          //建立value等于0的虚拟头节点
        ListNode pointer_g = greater;        //指向头节点的指针，为了保留两个列表的开头指针以便于最后连接
        ListNode less = new ListNode(0);
        ListNode pointer_l = less;
        
        ListNode curr = head;
        
        while(curr != null){
            if(curr.val < x){                //获取链表节点的值
                pointer_l.next = curr;
                pointer_l = curr;
                curr = curr.next;
            }
            else{
                pointer_g.next = curr;
                pointer_g = curr;
                curr = curr.next;
            }  
        }
        pointer_g.next = null;
        pointer_l.next = greater.next;
        return less.next;                    //避开虚拟头节点

No.203
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode sentinel = new ListNode(0);
        sentinel.next = head;
        
        ListNode prev = sentinel;            //删除链表节点只需要两个指针
        ListNode curr = head;
        
        while(curr != null){
            if(curr.val == val)              //若节点删除，则只有curr往前移动，prev保持不动
                prev.next = curr.next;
            else
                prev = curr;                 //若节点不删除，curr和prev都要移动
            curr = curr.next;
        }    
        return sentinel.next;                //避开虚拟头节点
    }
}

No.19
ListNode dummy = new ListNode(0);
dummy.next = head;
ListNode pointer1 = dummy;
ListNode pointer2 = pointer1.next;

while(n > 0){
    pointer2 = pointer2.next;
    n--;
}

while(pointer2 != null){
    pointer1 = pointer1.next;
    pointer2 = pointer2.next;
}

ListNode curr = pointer1.next;
pointer1.next = curr.next;

return dummy.next;


No.20
class Solution {
    
    private HashMap<Character, Character> mappings;
    
    public Solution(){
        this.mappings = new HashMap<Character, Character>();
        this.mappings.put(')', '(');
        this.mappings.put('}', '{');
        this.mappings.put(']', '[');
    }
    
    public boolean isValid(String s) {
        
        Stack<Character> stack = new Stack<Character>();
        
        for(char c : s.toCharArray()){
            if(this.mappings.containsKey(c)){
                
                char topelement = stack.empty() ? '#' : stack.pop();  
                
                if(topelement != this.mappings.get(c))
                    return false;
            }
            
            else
                stack.push(c);
            
        }
        
        return stack.empty();
    }
}

No.102
//BFS广度优先遍历implementation
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> levels = new ArrayList<List<Integer>>(); //新建一个二维数组来存储遍历结果，ArrayList中存List<Interger>元素
        if (root == null)
            return levels;  //空树直接返回空数组
        
        Queue<TreeNode> queue = new LinkedList<TreeNode>();  //使用LinkedList作为队列，队列中元素是树的节点
        queue.add(root);  //把根节点插入到队列中作为第一个元素
        int level = 0;    //树的层数标志，也标志二维数组中的第几行
        while( !queue.isEmpty() ){
            levels.add(new ArrayList<Integer>());  //在二维数组中添加一个空一维数组元素作为矩阵的一行，每到新一层添加一行
            
            int level_length = queue.size();  //同一层树节点的个数
            for(int i = 0 ; i < level_length; i++){  //遍历数列中属于当前层的节点
                TreeNode node = queue.remove();  //从队列中第一个元素开始取
                levels.get(level).add(node.val); //把node.val存在二维数组中的第level行相应的位置
                
                if(node.left != null)          //把每个节点的子节点存入队列，这时level_length依旧是原长度->这次循环不会遍历新加入的元素
                    queue.add(node.left);
                if(node.right != null)
                    queue.add(node.right);
            }
            level++;    //到矩阵的下一行    
        }
        return levels;
    }
}
Recursion：
class Solution {
    List<List<Integer>> levels = new ArrayList<List<Integer>>();

    public void helper(TreeNode node, int level) {
        // start the current level
        if (levels.size() == level)
            levels.add(new ArrayList<Integer>());

         // fulfil the current level
         levels.get(level).add(node.val);

         // process child nodes for the next level
         if (node.left != null)
            helper(node.left, level + 1);
         if (node.right != null)
            helper(node.right, level + 1);
    }
    
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) return levels;
        helper(root, 0);
        return levels;
    }
}

No。347
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // O(1) time
        if (k == nums.length) {
            return nums;
        }
        
        // 1. build hash map : character and how often it appears
        // O(N) time
        Map<Integer, Integer> count = new HashMap();
        for (int n: nums) {
          count.put(n, count.getOrDefault(n, 0) + 1);
        }

        // init heap 'the less frequent element first'
        Queue<Integer> heap = new PriorityQueue<>((n1, n2) -> count.get(n1) - count.get(n2));

        // 2. keep k top frequent elements in the heap
        // O(N log k) < O(N log N) time
        for (int n: count.keySet()) {
          heap.add(n);
          if (heap.size() > k) heap.poll();    
        }

        // 3. build an output array
        // O(k log k) time
        int[] top = new int[k];
        for(int i = k - 1; i >= 0; --i) {
            top[i] = heap.poll();
        }
        return top;
    }
}

No.23
class Solution {
    public ListNode mergeKLists(ListNode[] lists) { 
 
        Queue<ListNode> q = new PriorityQueue<>((n1, n2) -> n1.val - n2.val); //最小堆
        for(ListNode l : lists){
            if(l!=null){
                q.add(l);                //把每个链表（的头节点）入堆（每个头节点还是和身子连在一起的）
            }        
        }
        ListNode head = new ListNode(0);
        ListNode point = head;
        while(!q.isEmpty()){ 
            point.next = q.poll();       //将头节点最小的一个链表弹出
            point = point.next;          //将整个链表连在目标链表上（但其实只为了获取头节点元素）
            ListNode next = point.next;  //判断连上的链表出头节点外是否还有其他节点
            if(next!=null){              //若有，则将出头节点外剩下的子链表入堆
                q.add(next);             //每次从堆里面弹出头节点最小的那个链表，只将该链表的头节点放入目标链表（但其实剩下的部分也会留在目标链表中，但下一次循环又会被新的剩余部分覆盖），然后把剩下的没有头的部分作为一个新链表入堆
            }
        }
        return head.next;
    }
}

No.226
class Solution {
    public TreeNode invertTree(TreeNode root) { //含义：返回以root为节点反转后的二叉树
    if (root == null) 
        return null;
    
    TreeNode right = invertTree(root.right); //先将root.right为根的二叉树反转
    TreeNode left = invertTree(root.left);   //再将root.left为根的二叉树反转
    root.left = right;                       //将两个反转后的二叉树交换位置
    root.right = left;
    return root;
    }
}

No.100
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // p and q are both null
    if (p == null && q == null) 
        return true;                      //递归到底情况1
    // one of p and q is null
    if (q == null || p == null) 
        return false;                     //递归到底情况2
    if (p.val != q.val) 
        return false                      //若根节点值相同且左右子树相同，则返回true
    return isSameTree(p.right, q.right) && isSameTree(p.left, q.left);  //两棵子树都必须满足
    }
}

No.112
class Solution {
  public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null)                                  //终止条件=初始时的corner case
      return false;

    sum -= root.val;
    if ((root.left == null) && (root.right == null))
      return (sum == 0);
    return hasPathSum(root.left, sum) || hasPathSum(root.right, sum); //两棵子树有一棵满足即可
  }
}

No.257
class Solution {
  public void construct_paths(TreeNode root, String path, LinkedList<String> paths) { //寻找由上而下的未知数（路径），要用返回值为空的递归函数，然后把一个或多个数据结构传给递归函数，并且这个数据结构在整个递归过程中跟踪变化
    if (root != null) {                      //是否为null的判断必须放在递归函数内部
      path += Integer.toString(root.val);    //每一次递归都更新path
      if ((root.left == null) && (root.right == null))  // if reach a leaf
        paths.add(path);  // update paths    //但只有每次到叶子节点时才更新paths
      else {
        path += "->";  // extend the current path
        construct_paths(root.left, path, paths);
        construct_paths(root.right, path, paths);
      }
    }
  }

  public List<String> binaryTreePaths(TreeNode root) {
    LinkedList<String> paths = new LinkedList();
    construct_paths(root, "", paths);
    return paths;
  }
}

No.200
//递归函数的return表达的意思是返回到上一层（上一个节点）处，并把需要的值提供给该节点
class Solution {
    void dfs(char[][] grid, int r, int c){  //是把grid直接传进来，通过DFS把已经连通的全都置为0
        int nr = grid.length;     //四个方向的深度优先：先从原点沿着一个方向不停深入，等到达底端的时候返回到路径中的上一个点再进行四个方向上的DFS
        int nc = grid[0].length;  //树是两个方向的深度优先
        
        if(r<0 || c<0 || r>=nr || c>=nc || grid[r][c] == '0')
            return;           //不（/无法）改变当前节点的值（不用置为0），直接返回到上一个节点处
        
        grid[r][c] = '0';
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }
    
    public int numIslands(char[][] grid) {    
        if(grid == null || grid.length == 0)
            return 0;
        
        int num_islands = 0;
        int nr = grid.length;
        int nc = grid[0].length;
        for(int r = 0 ; r < nr ; r++){
            for(int c = 0 ; c < nc ; c++){
                if(grid[r][c] == '1'){
                    num_islands++;
                    dfs(grid, r, c);
                }
            }
        }
        return num_islands;
    }
}

No.198
Let us look at the case n = 1, clearly f(1) = A1.

Now, let us look at n = 2, which f(2) = max(A1, A2).

For n = 3, you have basically the following two options:

Rob the third house, and add its amount to the first house's amount.

Do not rob the third house, and stick with the maximum amount of the first two houses.

Clearly, you would want to choose the larger of the two options at each step.

Therefore, we could summarize the formula as following:

f(k) = max(f(k – 2) + Ak, f(k – 1))

 public int rob(int[] nums) {
        int prevMax = 0;
        int currMax = 0;
    for (int x : nums) {
        int temp = currMax;                        //temp用来实现f(k-2)
        currMax = Math.max(prevMax + x, currMax);  
        prevMax = temp;
    }
    return currMax;
    }
    
No.120
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {  //解决dp之前先画grid！
        int n = triangle.size();     //List的size
        int dp[][] = new int[n][n];  //初始化二维数组
        
        for(List<Integer> strian : triangle){     //用List数组把dp数组初始化
            for(int i = 0 ; i < strian.size() ; i++){
                dp[strian.size() - 1][i] = strian.get(i);
            }
        }
        
        for(int i = n-2 ; i >=0 ; i--)      //最后一行已经被初始化了
            for(int k = 0 ; k <= i ; k++){
                dp[i][k] = dp[i][k] + Math.min(dp[i+1][k], dp[i+1][k+1]);
            }
        return dp[0][0];
    }
}

No.416
//判断“是否可行”背包问题
class Solution {
    public boolean canPartition(int[] nums) {
        int totalSum = 0;
        // find sum of all array elements
        for (int num : nums) {
            totalSum += num;
        }
        // if totalSum is odd,it cannot be partitioned into equal sum subset
        if (totalSum % 2 != 0) return false;
        int subSetSum = totalSum / 2;
        int n = nums.length;
        
        boolean dp[][] = new boolean[n][subSetSum + 1];    //i代表从nums[0]到nums[i]中选取subset使其满足条件，i的取值从0到n-1，一共n个
                                                           //subSetSum代表剩余容量，取值从0到subSetSum，一共subSetSum+1个
        
        for(int i = 0 ; i <= subSetSum ; i++){             //初始化i=0的一整行，M[0，w]
            if(i == 0 || i == nums[0])
                dp[0][i] = true;
            else
                dp[0][i] = false;
        }
        
        for(int i = 1 ; i < n ; i++){                     //循环n-2次，i=0时已被初始化，i最多取到n-1
            for(int j = 0 ; j < subSetSum + 1 ; j++){     //循环subSetSUm+1次
                if(j >= nums[i]){
                    dp[i][j] = dp[i - 1][j] || (dp[i - 1][j - nums[i]]); 
                }
                else
                    dp[i][j] = dp[i - 1][j];    
            }
        }
        return dp[n-1][subSetSum];
    }
}
