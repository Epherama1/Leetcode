No.75 Sort Colors
三路快速排序的关键是，确定每个元素区间的范围，闭区间还是开区间。循环条件是区间之间没有交集（[li+1, i）和 [gt,r]的循环条件是i<gt, i这个未定元素进入某一个元素区间内部时，循环终止）。
在排序开始前，要保证三个区间里一个元素都没有 : lt = -1, gt = nums.size(), i从0开始。

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int> nums;
        
        for(int i = 0; i< m; i++){
            nums[i] = nums1[i];
        }
        
        int i, j = 0;
        for(int k = 0; k < m+n; k++){
            if( nums[i] < nums2[j] ){
                nums1[k] = nums[i];
                i++;
            }
            
            else if(nums[i] > nums2[j]){
                nums1[k] = nums2[j];
                j++;
            }
            
            else{
                nums1[k] = nums[i];
                k++;
                nums1[k] = nums2[j];
                i++;
                j++;
            }                  
        }
        
        
    }
};

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int> nums;
        for(int i = 0; i<m; i++)
            nums[i] = nums1[i];
        int i,j = 0;
        while(j < n){
            if(nums[i] < nums2[j]){
                nums1[i] = nums[i];
            }
                
            else if(nums1[i] > nums2[j]){
                
            }
        }
        
    }
};

No.167 对撞指针

No.209 滑动窗口

滑动窗口和对撞指针的区别：滑动窗口要求连续元素

No.349 Set的使用
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
       Set<Integer> set = new HashSet<>();  //set的初始化
        for(int i : nums1)
            set.add(i);
        
        Set<Integer> set2 = new HashSet<>();   //Set的循环
        for(int i : nums2)
            set2.add(i);
        
        List<Integer> result = new ArrayList<>(); //ArrayList的初始化
        
        for(int i : set2){
            if(set.contains(i)){
                result.add(i);
            }
        }
        
        int[] ints = new int[result.size()];    //Array的初始化
        for(int i = 0; i < result.size(); i++)
            ints[i] = result.get(i);          //ArrayList不能直接用[i]获取元素，要用get()
        
        return ints;
    }
}


No.350 Map的使用
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
    
    HashMap<Integer, Integer> m = new HashMap<>(); //Map的初始化
    for (int n : nums1) {
        m.put(n, m.getOrDefault(n, 0) + 1);        //将数组元素存入Map中
    }
    int k = 0;
    for (int n : nums2) {
        int cnt = m.getOrDefault(n, 0);            
        if (cnt > 0) {
            nums1[k++] = n;                       //为节省空间，可以使用已经被存储过的数据结构
            m.put(n, cnt - 1);                    //Map中元素使用完频率减一（更新Map）
        }
    }
    return Arrays.copyOfRange(nums1, 0, k);
    }
}

No.202 
//用set判断循环，比如分割某个数，几次循环之后又回到了最开始的数，那这就是死循环
Set<Integer> seen = new HashSet<>();
        
        while(true){
            if(seen.contains(n))
                return false;
            if(n==1)
                return true;
            seen.add(n);
            n = getNext(n);

No.1
public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> m = new HashMap<>();
        for(int i = 0; i < nums.length ; i++){
            m.put(nums[i], i);
        }
        
        for(int i = 0; i < nums.length ; i++){
            int compelement = target - nums[i];
            if(m.containsKey(compelement) && m.get(compelement)!=i){
                return new int[] {i, m.get(compelement)};
            }
        }
        throw new IllegalArgumentException("No two sum solution");

No.219
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set<Integer> set = new HashSet<>();
        for(int i = 0 ; i < nums.length ; i++){
            if(set.contains(nums[i]))             //判断两个数是否相等可以通过判断set中是否存在
                return true;
            set.add(nums[i]);
            if(set.size() > k)
                set.remove(nums[i-k]);    //把set当作滑动窗口，维持set中的元素数量是k
        }
        return false;
    }
}

No.206
ListNode prev = null;
ListNode curr = head;
     while(curr != null){               //以谁作为循环的判断条件，在循环内就必须以谁的更新结尾，为了确保不会出现null.next，如果还需要更新之后的节点，那就在每次循环的开始更新，需要这种更新的节点不用在循环外定义，在循环内定义即可
            ListNode next = curr.next;  //在下一次循环里更新上一次的next，只能用一定不为null的节点.next，因为null.next报错空指针
            curr.next = prev;
            prev = curr;
            curr = next;
        }

No.24
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null)
            return null;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        ListNode prev = dummy;                          //初始化到循环判断的那一个节点即可，剩下的要不不需要，要不就是需要在循环哪初始化
        ListNode firstnode = head;
        
        while(firstnode != null) {                      //以谁作为循环的判断条件，在循环内就必须以谁的更新结尾，为了确保不会出现null.next，如果还需要更新之后的节点，那就在每次循环的开始更新，需要这种更新的节点不用在循环外定义，在循环内定义即可                                                 
            ListNode secondnode = firstnode.next;       //在下一次循环里更新上一次的next，只能用一定不为null的节点.next，因为null.next报错空指针
            if(secondnode == null)
                break;
            
            prev.next = secondnode;
            firstnode.next = secondnode.next;
            secondnode.next = firstnode;
            
            prev = firstnode;                           //往前移动一个单位即可，因为已经两两交换了位置相当于移动了两个单位
            firstnode = prev.next;
            
        }
        
        return dummy.next;
    }
}


No.92
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if(head == null)
            return null;
        
        ListNode prev = null;
        ListNode curr = head;
        while(m > 1){                   //把prev和curr指针移到合适的位置，从左到右赋值
            prev = curr;
            curr = curr.next;
            m--;
            n--;
        }
        ListNode conA = prev;           //保存reverse前的prev和curr为了reverse后保证链表的顺序性，不会出现环
        ListNode tail = curr;   
        
        while(n > 0){
            ListNode next = curr.next;  //链表reverse需要三个指针：prev，curr，next
            curr.next = prev;
            prev = curr;
            curr = next;
            n--;
        }
        
        if(conA != null)               //已经reverse完的子链头节点（原先的尾节点）被之前存的prev（主链上一个节点）指向，子链的尾节点（原先的头节点）指向主链的下一个节点（可以为null）
            conA.next = prev;
        else                           //reverse完成后，prev指向子链的头节点，curr指向主链的下一个节点（可以为null）
            head = prev;               //若主链的上一个节点为null，则子链目前的头节点作为head
        
        tail.next = curr;
        return head;
    }
}

No.86
ListNode greater = new ListNode(0);          //建立value等于0的虚拟头节点
        ListNode pointer_g = greater;        //指向头节点的指针，为了保留两个列表的开头指针以便于最后连接
        ListNode less = new ListNode(0);
        ListNode pointer_l = less;
        
        ListNode curr = head;
        
        while(curr != null){
            if(curr.val < x){                //获取链表节点的值
                pointer_l.next = curr;
                pointer_l = curr;
                curr = curr.next;
            }
            else{
                pointer_g.next = curr;
                pointer_g = curr;
                curr = curr.next;
            }  
        }
        pointer_g.next = null;
        pointer_l.next = greater.next;
        return less.next;                    //避开虚拟头节点

No.203
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode sentinel = new ListNode(0);
        sentinel.next = head;
        
        ListNode prev = sentinel;            //删除链表节点只需要两个指针
        ListNode curr = head;
        
        while(curr != null){
            if(curr.val == val)              //若节点删除，则只有curr往前移动，prev保持不动
                prev.next = curr.next;
            else
                prev = curr;                 //若节点不删除，curr和prev都要移动
            curr = curr.next;
        }    
        return sentinel.next;                //避开虚拟头节点
    }
}

No.19
ListNode dummy = new ListNode(0);
dummy.next = head;
ListNode pointer1 = dummy;
ListNode pointer2 = pointer1.next;

while(n > 0){
    pointer2 = pointer2.next;
    n--;
}

while(pointer2 != null){
    pointer1 = pointer1.next;
    pointer2 = pointer2.next;
}

ListNode curr = pointer1.next;
pointer1.next = curr.next;

return dummy.next;


No.20
class Solution {
    
    private HashMap<Character, Character> mappings;
    
    public Solution(){
        this.mappings = new HashMap<Character, Character>();
        this.mappings.put(')', '(');
        this.mappings.put('}', '{');
        this.mappings.put(']', '[');
    }
    
    public boolean isValid(String s) {
        
        Stack<Character> stack = new Stack<Character>();
        
        for(char c : s.toCharArray()){
            if(this.mappings.containsKey(c)){
                
                char topelement = stack.empty() ? '#' : stack.pop();  
                
                if(topelement != this.mappings.get(c))
                    return false;
            }
            
            else
                stack.push(c);
            
        }
        
        return stack.empty();
    }
}

No.102
//BFS广度优先遍历implementation
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> levels = new ArrayList<List<Integer>>(); //新建一个二维数组来存储遍历结果，ArrayList中存List<Interger>元素
        if (root == null)
            return levels;  //空树直接返回空数组
        
        Queue<TreeNode> queue = new LinkedList<TreeNode>();  //使用LinkedList作为队列，队列中元素是树的节点
        queue.add(root);  //把根节点插入到队列中作为第一个元素
        int level = 0;    //树的层数标志，也标志二维数组中的第几行
        while( !queue.isEmpty() ){
            levels.add(new ArrayList<Integer>());  //在二维数组中添加一个空一维数组元素作为矩阵的一行，每到新一层添加一行
            
            int level_length = queue.size();  //同一层树节点的个数
            for(int i = 0 ; i < level_length; i++){  //遍历数列中属于当前层的节点
                TreeNode node = queue.remove();  //从队列中第一个元素开始取
                levels.get(level).add(node.val); //把node.val存在二维数组中的第level行相应的位置
                
                if(node.left != null)          //把每个节点的子节点存入队列，这时level_length依旧是原长度->这次循环不会遍历新加入的元素
                    queue.add(node.left);
                if(node.right != null)
                    queue.add(node.right);
            }
            level++;    //到矩阵的下一行    
        }
        return levels;
    }
}
Recursion：
class Solution {
    List<List<Integer>> levels = new ArrayList<List<Integer>>();

    public void helper(TreeNode node, int level) {
        // start the current level
        if (levels.size() == level)
            levels.add(new ArrayList<Integer>());

         // fulfil the current level
         levels.get(level).add(node.val);

         // process child nodes for the next level
         if (node.left != null)
            helper(node.left, level + 1);
         if (node.right != null)
            helper(node.right, level + 1);
    }
    
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) return levels;
        helper(root, 0);
        return levels;
    }
}

No。347
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // O(1) time
        if (k == nums.length) {
            return nums;
        }
        
        // 1. build hash map : character and how often it appears
        // O(N) time
        Map<Integer, Integer> count = new HashMap();
        for (int n: nums) {
          count.put(n, count.getOrDefault(n, 0) + 1);
        }

        // init heap 'the less frequent element first'
        Queue<Integer> heap = new PriorityQueue<>((n1, n2) -> count.get(n1) - count.get(n2));

        // 2. keep k top frequent elements in the heap
        // O(N log k) < O(N log N) time
        for (int n: count.keySet()) {
          heap.add(n);
          if (heap.size() > k) heap.poll();    
        }

        // 3. build an output array
        // O(k log k) time
        int[] top = new int[k];
        for(int i = k - 1; i >= 0; --i) {
            top[i] = heap.poll();
        }
        return top;
    }
}

No.23
class Solution {
    public ListNode mergeKLists(ListNode[] lists) { 
 
        Queue<ListNode> q = new PriorityQueue<>((n1, n2) -> n1.val - n2.val); //最小堆
        for(ListNode l : lists){
            if(l!=null){
                q.add(l);                //把每个链表（的头节点）入堆（每个头节点还是和身子连在一起的）
            }        
        }
        ListNode head = new ListNode(0);
        ListNode point = head;
        while(!q.isEmpty()){ 
            point.next = q.poll();       //将头节点最小的一个链表弹出
            point = point.next;          //将整个链表连在目标链表上（但其实只为了获取头节点元素）
            ListNode next = point.next;  //判断连上的链表出头节点外是否还有其他节点
            if(next!=null){              //若有，则将出头节点外剩下的子链表入堆
                q.add(next);             //每次从堆里面弹出头节点最小的那个链表，只将该链表的头节点放入目标链表（但其实剩下的部分也会留在目标链表中，但下一次循环又会被新的剩余部分覆盖），然后把剩下的没有头的部分作为一个新链表入堆
            }
        }
        return head.next;
    }
}

No.226
class Solution {
    public TreeNode invertTree(TreeNode root) { //含义：返回以root为节点反转后的二叉树
    if (root == null) 
        return null;
    
    TreeNode right = invertTree(root.right); //先将root.right为根的二叉树反转
    TreeNode left = invertTree(root.left);   //再将root.left为根的二叉树反转
    root.left = right;                       //将两个反转后的二叉树交换位置
    root.right = left;
    return root;
    }
}

No.100
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // p and q are both null
    if (p == null && q == null) 
        return true;                      //递归到底情况1
    // one of p and q is null
    if (q == null || p == null) 
        return false;                     //递归到底情况2
    if (p.val != q.val) 
        return false                      //若根节点值相同且左右子树相同，则返回true
    return isSameTree(p.right, q.right) && isSameTree(p.left, q.left);  //两棵子树都必须满足
    }
}

No.112
class Solution {
  public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null)                                  //终止条件=初始时的corner case
      return false;

    sum -= root.val;
    if ((root.left == null) && (root.right == null))
      return (sum == 0);
    return hasPathSum(root.left, sum) || hasPathSum(root.right, sum); //两棵子树有一棵满足即可
  }
}

No.257
class Solution {
  public void construct_paths(TreeNode root, String path, LinkedList<String> paths) { //寻找由上而下的未知数（路径），要用返回值为空的递归函数，然后把一个或多个数据结构传给递归函数，并且这个数据结构在整个递归过程中跟踪变化
    if (root != null) {                      //是否为null的判断必须放在递归函数内部
      path += Integer.toString(root.val);    //每一次递归都更新path
      if ((root.left == null) && (root.right == null))  // if reach a leaf
        paths.add(path);  // update paths    //但只有每次到叶子节点时才更新paths
      else {
        path += "->";  // extend the current path
        construct_paths(root.left, path, paths);
        construct_paths(root.right, path, paths);
      }
    }
  }

  public List<String> binaryTreePaths(TreeNode root) {
    LinkedList<String> paths = new LinkedList();
    construct_paths(root, "", paths);
    return paths;
  }
}

No.200
//递归函数的return表达的意思是返回到上一层（上一个节点）处，并把需要的值提供给该节点
class Solution {
    void dfs(char[][] grid, int r, int c){  //是把grid直接传进来，通过DFS把已经连通的全都置为0
        int nr = grid.length;     //四个方向的深度优先：先从原点沿着一个方向不停深入，等到达底端的时候返回到路径中的上一个点再进行四个方向上的DFS
        int nc = grid[0].length;  //树是两个方向的深度优先
        
        if(r<0 || c<0 || r>=nr || c>=nc || grid[r][c] == '0')
            return;           //不（/无法）改变当前节点的值（不用置为0），直接返回到上一个节点处
        
        grid[r][c] = '0';
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }
    
    public int numIslands(char[][] grid) {    
        if(grid == null || grid.length == 0)
            return 0;
        
        int num_islands = 0;
        int nr = grid.length;
        int nc = grid[0].length;
        for(int r = 0 ; r < nr ; r++){
            for(int c = 0 ; c < nc ; c++){
                if(grid[r][c] == '1'){
                    num_islands++;
                    dfs(grid, r, c);
                }
            }
        }
        return num_islands;
    }
}

No.198
Let us look at the case n = 1, clearly f(1) = A1.

Now, let us look at n = 2, which f(2) = max(A1, A2).

For n = 3, you have basically the following two options:

Rob the third house, and add its amount to the first house's amount.

Do not rob the third house, and stick with the maximum amount of the first two houses.

Clearly, you would want to choose the larger of the two options at each step.

Therefore, we could summarize the formula as following:

f(k) = max(f(k – 2) + Ak, f(k – 1))

 public int rob(int[] nums) {
        int prevMax = 0;
        int currMax = 0;
    for (int x : nums) {
        int temp = currMax;                        //temp用来实现f(k-2)
        currMax = Math.max(prevMax + x, currMax);  
        prevMax = temp;
    }
    return currMax;
    }
    
No.120
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {  //解决dp之前先画grid！
        int n = triangle.size();     //List的size
        int dp[][] = new int[n][n];  //初始化二维数组
        
        for(List<Integer> strian : triangle){     //用List数组把dp数组初始化
            for(int i = 0 ; i < strian.size() ; i++){
                dp[strian.size() - 1][i] = strian.get(i);
            }
        }
        
        for(int i = n-2 ; i >=0 ; i--)      //最后一行已经被初始化了
            for(int k = 0 ; k <= i ; k++){
                dp[i][k] = dp[i][k] + Math.min(dp[i+1][k], dp[i+1][k+1]);
            }
        return dp[0][0];
    }
}

No.416
//判断“是否可行”背包问题
class Solution {
    public boolean canPartition(int[] nums) {
        int totalSum = 0;
        // find sum of all array elements
        for (int num : nums) {
            totalSum += num;
        }
        // if totalSum is odd,it cannot be partitioned into equal sum subset
        if (totalSum % 2 != 0) return false;
        int subSetSum = totalSum / 2;
        int n = nums.length;
        
        boolean dp[][] = new boolean[n][subSetSum + 1];    //i代表从nums[0]到nums[i]中选取subset使其满足条件，i的取值从0到n-1，一共n个
                                                           //subSetSum代表剩余容量，取值从0到subSetSum，一共subSetSum+1个
        
        for(int i = 0 ; i <= subSetSum ; i++){             //初始化i=0的一整行，M[0，w]
            if(i == 0 || i == nums[0])
                dp[0][i] = true;
            else
                dp[0][i] = false;
        }
        
        for(int i = 1 ; i < n ; i++){                     //循环n-2次，i=0时已被初始化，i最多取到n-1
            for(int j = 0 ; j < subSetSum + 1 ; j++){     //循环subSetSUm+1次
                if(j >= nums[i]){
                    dp[i][j] = dp[i - 1][j] || (dp[i - 1][j - nums[i]]); 
                }
                else
                    dp[i][j] = dp[i - 1][j];    
            }
        }
        return dp[n-1][subSetSum];
    }
}

No.322
                                             //完全背包问题，数组里存放的是种类，并不是所有元素
class Solution {
    public int coinChange(int[] coins, int amount) {
        if(coins == null || coins.length == 0)
            return -1;
        
        int n = coins.length;
        
        int dp[][] = new int[n][amount+1];
        
        for(int i = 0 ; i <= amount ; i++){
            int s = i/coins[0];              //容量问题中初始化：看是否可以用无限次第一个物品来把从0到amount的背包填满 => 整除问题
            int y = i%coins[0];              
            
            if(y==0)                         //若可以整除，则把商作为初始值
                dp[0][i] = s;
            else                             //若不能整除，则看整个问题是求最大值还是最小值，若是求最小值则选一个极大值作为初始值，若是求最大值则选一个极小值作为初始值
                dp[0][i] = 10001;            //极大值和极小值的选择根据问题规模选
           
        }
        
        for(int i = 1 ; i < n ; i++)
            for(int j = 0 ; j <=amount ; j++){     //种类数组的循环过程和数量数组一样，都是+1
                if(coins[i] <= j)
                    dp[i][j] = Math.min( 1 + dp[i][j - coins[i]] , dp[i-1][j]  );
                else
                    dp[i][j] = dp[i-1][j];
            }
        if(dp[n-1][amount] == 10001)
            return -1;
        else
            return dp[n-1][amount];    
    }
}

public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordDictSet = new HashSet<>(wordDict);
        boolean[] dp = new boolean[s.length()];
        dp[0] = false;
        for (int i = 1; i < s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.contains(s.substring(j, i+1))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()-1];
    }
}

Prefix Sum: Find a number of continuous subarrays/submatrices/tree paths that sum to target

No.437
class Solution {
    int count = 0;
    int k;
    HashMap<Integer, Integer> h = new HashMap();
    
    public void preorder(TreeNode node, int currSum) {
        if (node == null)                              //遍历到叶子节点直接返回
            return;
        
        // current prefix sum
        currSum += node.val;

        // here is the sum we're looking for
        if (currSum == k)
            count++;
        
        // number of times the curr_sum − k has occured already, 
        // determines the number of times a path with sum k 
        // has occured upto the current node
        count += h.getOrDefault(currSum - k, 0);
        
        // add the current sum into hashmap
        // to use it during the child nodes processing
        h.put(currSum, h.getOrDefault(currSum, 0) + 1);

        // process left subtree
        preorder(node.left, currSum);
        // process right subtree
        preorder(node.right, currSum);

        // remove the current sum from the hashmap
        // in order not to use it during 
        // the parallel subtree processing
        h.put(currSum, h.get(currSum) - 1);
    }    
            
    public int pathSum(TreeNode root, int sum) {
        k = sum;
        preorder(root, 0);
        return count;
    }
}

No.560
public class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0, currSum = 0;
        HashMap<Integer, Integer> h = new HashMap();
        
        for (int num : nums) {
            // current prefix sum
            currSum += num;
            
            // situation 1:  
            // continuous subarray starts 
            // from the beginning of the array
            if (currSum == k)
                count++;
            
            // situation 2:
            // number of times the curr_sum − k has occured already, 
            // determines the number of times a subarray with sum k 
            // has occured upto the current index
            count += h.getOrDefault(currSum - k, 0);
            
            // add the current sum
            h.put(currSum, h.getOrDefault(currSum, 0) + 1);    
        }
                
        return count;
    }
}

No.98
//判断BST是否valid
class Solution {
    public boolean helper(TreeNode node, Integer lower, Integer upper){  //lower和upper是通过节点node的父节点获得的（把当前节点当成子节点而不是当成父节点来判断下面的子节点）
        if(node == null)
            return true;          //节点为空，达到树的最底端
        
        int val = node.val;                //判断本节点是否满足BST的要求
        if(lower != null && val <= lower)
            return false;
        if(upper != null && val >= upper)
            return false;
        
        if(!helper(node.left, lower, val)) //若本节点满足要求，判断左子树是否满足要求
            return false;
        if(!helper(node.right, val, upper))  //若本节点满足要求，判断右子树是否满足要求
            return false;
        
        return true;
    }
    
    public boolean isValidBST(TreeNode root) {
        if(root == null)
            return false;  
        return helper(root, null, null);       //最开始根节点没有父节点，lower和upper无法获得就为null
    }
}

No.450
//删除二叉搜索树任意节点
class Solution {
    public int successor(TreeNode root) {     //找到右子树最小值（一次向右，之后一直向左，直到为空）
     root = root.right;
     while (root.left != null) root = root.left;
     return root.val;
  }
    public int predecessor(TreeNode root) {   //找到左子树最大值（一次向左，之后一直向右，直到为空）
    root = root.left;
    while (root.right != null) root = root.right;
    return root.val;
  }
    
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null) return null;                    
        
        if(root.val < key){                            //key在右子树中，删除右子树中的key并把节点返回
            root.right = deleteNode(root.right, key);
            return root;
        }
        
        else if(root.val > key){                       //key在左子树中，删除左子树中的key并把节点返回
            root.left = deleteNode(root.left, key);
            return root;
        }
        
        else{                                          //key在当前节点中
            if(root.left == null && root.right == null)    //若是叶子节点，直接删除（node = nll）
                return null;
            
            if(root.right == null){            //右子树为空，则把左子树中的最大值赋给要删除的节点，并删除此最大值
                root.val = predecessor(root);
                root.left = deleteNode(root.left, root.val);
                return root;
            }
            else{                    //左子树为空或者左右子树都不为空，把右子树的最小值赋给要删除的节点，并删除此最小值
                root.val = successor(root);
                root.right = deleteNode(root.right, root.val);
                return root;
            }           
        }
    }
}

Inorder traversal of BST is an array sorted in the ascending order.

public LinkedList<Integer> inorder(TreeNode root, LinkedList<Integer> arr) {
  if (root == null) return arr;
  inorder(root.left, arr);
  arr.add(root.val);
  inorder(root.right, arr);
  return arr;
}

Inorder traversal is not a unique identifier of BST. At the same time both preorder and postorder traversals are unique identifiers of BST.
The height-balanced restriction means that at each step one has to pick up the number in the middle as a root.
That works fine with arrays containing odd number of elements but there is no predefined choice for arrays with even number of elements.
One could choose left middle element, or right middle one, and both choices will lead to different height-balanced BSTs. 

No.108
//有序数组构建成平衡二叉树
//[]版本
class Solution {
    public TreeNode buildtree(int left, int right, int[] nums){
        if(left > right)
            return null;
        
        int m = (left + right)/2;
        TreeNode root = new TreeNode(nums[m]);   //需要知道每一个root的索引
        root.left = buildtree(left, m-1, nums);
        root.right = buildtree(m+1, right, nums);
        
        return root;
    }
    
    public TreeNode sortedArrayToBST(int[] nums) {
        return buildtree(0, nums.length-1, nums);
    }
}
//[)版本
class Solution {
    public TreeNode buildtree(int left, int right, int[] nums){
        if(left >= right)   //变了
            return null;
        
        int m = (left + right-1)/2;        //变了
        TreeNode root = new TreeNode(nums[m]);
        root.left = buildtree(left, m, nums);    //变了
        root.right = buildtree(m+1, right, nums);
        
        return root;
    }
    
    public TreeNode sortedArrayToBST(int[] nums) {
        return buildtree(0, nums.length, nums);    //变了
    }
}

Binary tree could be constructed from preorder and inorder traversal.
Inorder traversal of BST is an array sorted in the ascending order.
preorder：数组的第一个元素是root
postorder：数组的最后一个元素是root
inorder：把数组升序排列得到的结果就是中序遍历，但可能的树也有很多种情况，因为不确定哪一个是root节点（可以通过preorder和postorder来判断哪一个是root）

//通过preorder traveral构建二叉树
//[]版本
class Solution {
    int root_index;
    int[] preorder;
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    
    public TreeNode buildtree(int left, int right){
        if(left == right+1)
            return null;
        
        int m_index = map.get(preorder[root_index]);
        TreeNode root = new TreeNode(preorder[root_index]);
        root_index++;
        
        root.left = buildtree(left, m_index-1);
        root.right = buildtree(m_index+1, right);
        return root;    
    }
    
    public TreeNode bstFromPreorder(int[] preorder) {
        this.preorder = preorder;
        this.root_index = 0;
        int [] inorder = Arrays.copyOf(preorder, preorder.length);
        Arrays.sort(inorder);
        
        int idx = 0;
        for(int val : inorder){
            this.map.put(val, idx++);
        }
            
        return buildtree(0, inorder.length-1);
    }
}
//[)版本
class Solution {
    int root_index;
    int[] preorder;
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    
    public TreeNode buildtree(int left, int right){
        if(left == right)               //变了
            return null;
        
        int m_index = map.get(preorder[root_index]);
        TreeNode root = new TreeNode(preorder[root_index]);
        root_index++;
        
        root.left = buildtree(left, m_index);       //变了
        root.right = buildtree(m_index+1, right);
        return root;    
    }
    
    public TreeNode bstFromPreorder(int[] preorder) {
        this.preorder = preorder;
        this.root_index = 0;
        int [] inorder = Arrays.copyOf(preorder, preorder.length);
        Arrays.sort(inorder);
        
        int idx = 0;
        for(int val : inorder){
            this.map.put(val, idx++);
        }
            
        return buildtree(0, inorder.length);     //变了
    }
}

https://leetcode.com/problems/kth-smallest-element-in-a-bst/Figures/230/bfs_dfs.png

No.230 //Kth Smallest Element in a BST
class Solution {
    public ArrayList<Integer> inorder(TreeNode root, ArrayList<Integer> arr){    //函数声明中的
        if(root == null)
            return arr;             //没有节点的话，则对数组不进行任何操作，直接返回
        inorder(root.left, arr);
        arr.add(root.val);
        inorder(root.right, arr);
        return arr;
    }
    
    public int kthSmallest(TreeNode root, int k) {
        ArrayList<Integer> nums = inorder(root, new ArrayList<Integer>());   //如何在函数参数中新建实体化变量
        return nums.get(k-1);                                                //ArrayList取前k个参数
    }
}

No.236
不用this版本：
class Solution {

    TreeNode ans = null;     //（公共或私有）成员变量可以直接赋值

    public boolean recurseTree(TreeNode currentNode, TreeNode p, TreeNode q) { //该递归函数的作用是，查看以currentNode为根节点的树中是否含有p或者q
                                                                               //含有p或者q的三种情况：在根节点，在左子节点，在右子节点
                                                                               //
        // If reached the end of a branch, return false.
        if (currentNode == null) {
            return false;
        }

        // Left Recursion. If left recursion returns true, set left = 1 else 0
        int left = recurseTree(currentNode.left, p, q) ? 1 : 0;

        // Right Recursion
        int right = recurseTree(currentNode.right, p, q) ? 1 : 0;
        
        // If the current node is one of p or q
        int mid = (currentNode == p || currentNode == q) ? 1 : 0;


        // If any two of the flags left, right or mid become True
        if (mid + left + right >= 2) {
            ans = currentNode;
        }

        // Return true if any one of the three bool values is True.
        return (mid + left + right > 0);
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // Traverse the tree
        recurseTree(root, p, q);
        return ans;
    }
}

//用this版本：
class Solution {

    private TreeNode ans;   

    public Solution() {            //成员变量可以通过构造函数赋值，私有也可以不用this
        // Variable to store LCA node.
        this.ans = null;
    }

    private boolean recurseTree(TreeNode currentNode, TreeNode p, TreeNode q) {    //私有函数也可以不用this

        // If reached the end of a branch, return false.
        if (currentNode == null) {
            return false;
        }

        // Left Recursion. If left recursion returns true, set left = 1 else 0
        int left = this.recurseTree(currentNode.left, p, q) ? 1 : 0;

        // Right Recursion
        int right = this.recurseTree(currentNode.right, p, q) ? 1 : 0;

        // If the current node is one of p or q
        int mid = (currentNode == p || currentNode == q) ? 1 : 0;


        // If any two of the flags left, right or mid become True
        if (mid + left + right >= 2) {
            this.ans = currentNode;
        }

        // Return true if any one of the three bool values is True.
        return (mid + left + right > 0);
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // Traverse the tree
        this.recurseTree(root, p, q);
        return this.ans;
    }
}
