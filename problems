No.75 Sort Colors
三路快速排序的关键是，确定每个元素区间的范围，闭区间还是开区间。循环条件是区间之间没有交集（[li+1, i）和 [gt,r]的循环条件是i<gt, i这个未定元素进入某一个元素区间内部时，循环终止）。
在排序开始前，要保证三个区间里一个元素都没有 : lt = -1, gt = nums.size(), i从0开始。

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int> nums;
        
        for(int i = 0; i< m; i++){
            nums[i] = nums1[i];
        }
        
        int i, j = 0;
        for(int k = 0; k < m+n; k++){
            if( nums[i] < nums2[j] ){
                nums1[k] = nums[i];
                i++;
            }
            
            else if(nums[i] > nums2[j]){
                nums1[k] = nums2[j];
                j++;
            }
            
            else{
                nums1[k] = nums[i];
                k++;
                nums1[k] = nums2[j];
                i++;
                j++;
            }                  
        }
        
        
    }
};

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int> nums;
        for(int i = 0; i<m; i++)
            nums[i] = nums1[i];
        int i,j = 0;
        while(j < n){
            if(nums[i] < nums2[j]){
                nums1[i] = nums[i];
            }
                
            else if(nums1[i] > nums2[j]){
                
            }
        }
        
    }
};

No.167 对撞指针

No.209 滑动窗口

滑动窗口和对撞指针的区别：滑动窗口要求连续元素

No.349 Set的使用
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
       Set<Integer> set = new HashSet<>();  //set的初始化
        for(int i : nums1)
            set.add(i);
        
        Set<Integer> set2 = new HashSet<>();   //Set的循环
        for(int i : nums2)
            set2.add(i);
        
        List<Integer> result = new ArrayList<>(); //ArrayList的初始化
        
        for(int i : set2){
            if(set.contains(i)){
                result.add(i);
            }
        }
        
        int[] ints = new int[result.size()];    //Array的初始化
        for(int i = 0; i < result.size(); i++)
            ints[i] = result.get(i);          //ArrayList不能直接用[i]获取元素，要用get()
        
        return ints;
    }
}


No.350 Map的使用
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
    
    HashMap<Integer, Integer> m = new HashMap<>(); //Map的初始化
    for (int n : nums1) {
        m.put(n, m.getOrDefault(n, 0) + 1);        //将数组元素存入Map中
    }
    int k = 0;
    for (int n : nums2) {
        int cnt = m.getOrDefault(n, 0);            
        if (cnt > 0) {
            nums1[k++] = n;                       //为节省空间，可以使用已经被存储过的数据结构
            m.put(n, cnt - 1);                    //Map中元素使用完频率减一（更新Map）
        }
    }
    return Arrays.copyOfRange(nums1, 0, k);
    }
}

No.202 
//用set判断循环，比如分割某个数，几次循环之后又回到了最开始的数，那这就是死循环
Set<Integer> seen = new HashSet<>();
        
        while(true){
            if(seen.contains(n))
                return false;
            if(n==1)
                return true;
            seen.add(n);
            n = getNext(n);

No.1
public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> m = new HashMap<>();
        for(int i = 0; i < nums.length ; i++){
            m.put(nums[i], i);
        }
        
        for(int i = 0; i < nums.length ; i++){
            int compelement = target - nums[i];
            if(m.containsKey(compelement) && m.get(compelement)!=i){
                return new int[] {i, m.get(compelement)};
            }
        }
        throw new IllegalArgumentException("No two sum solution");

No.219
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set<Integer> set = new HashSet<>();
        for(int i = 0 ; i < nums.length ; i++){
            if(set.contains(nums[i]))             //判断两个数是否相等可以通过判断set中是否存在
                return true;
            set.add(nums[i]);
            if(set.size() > k)
                set.remove(nums[i-k]);    //把set当作滑动窗口，维持set中的元素数量是k
        }
        return false;
    }
}

No.206
ListNode prev = null;
ListNode curr = head;
     while(curr != null){
            ListNode next = curr.next;  //在下一次循环里更新上一次的next，只能用一定不为null的节点.next，因为null.next报错空指针
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        
No.92
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if(head == null)
            return null;
        
        ListNode prev = null;
        ListNode curr = head;
        while(m > 1){                   //把prev和curr指针移到合适的位置，从左到右赋值
            prev = curr;
            curr = curr.next;
            m--;
            n--;
        }
        ListNode conA = prev;           //保存reverse前的prev和curr为了reverse后保证链表的顺序性，不会出现环
        ListNode tail = curr;   
        
        while(n > 0){
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
            n--;
        }
        
        if(conA != null)               //已经reverse完的子链头节点（原先的尾节点）被之前存的prev（主链上一个节点）指向，子链的尾节点（原先的头节点）指向主链的下一个节点（可以为null）
            conA.next = prev;
        else                           //reverse完成后，prev指向子链的头节点，curr指向主链的下一个节点（可以为null）
            head = prev;               //若主链的上一个节点为null，则子链目前的头节点作为head
        
        tail.next = curr;
        return head;
    }
}
